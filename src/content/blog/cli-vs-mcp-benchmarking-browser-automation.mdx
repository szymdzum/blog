---
title: "CLI vs MCP on Chrome DevTools Protocol"
description: "I ran benchmarks comparing CLI tools against MCP servers for browser automation. CLI scored 77/100 vs MCP's 60/100. Here's what I found."
pubDate: 2025-11-23
category: "opinion"
tags: ["mcp", "cli", "browser-automation", "benchmarks", "ai-agents"]
keywords:
  [
    "Model Context Protocol",
    "MCP",
    "CLI tools",
    "browser automation",
    "Chrome DevTools Protocol",
    "AI agents",
    "token efficiency",
  ]
author: "Kumak"
showToc: true
featured: false
---

import TldrBox from '@components/TldrBox.astro';

<TldrBox>
CLI tools scored 77/100 versus MCP's 60/100 for browser automation tasks. Token efficiency favored CLI by 33%. The difference comes from selective queries vs full-page dumps, plus access to 300+ CDP methods that MCP structurally cannot expose.
</TldrBox>

Anthropic published an observation about [MCP and code execution](https://www.anthropic.com/engineering/code-execution-with-mcp): executable code in the filesystem might be more efficient for AI agents than protocol servers. Isn't that what CLI tools already are?

I tested this by comparing two approaches to browser automation:

- **CLI**: [bdg](https://github.com/szymdzum/browser-debugger-cli), a browser debugger CLI I built
- **MCP**: [Chrome DevTools MCP](https://github.com/anthropic/mcp-server-browserbase), the official Chrome DevTools Protocol server

Both interact with the Chrome DevTools Protocol. Same underlying capabilities. The question: does the interface matter?

## Methodology

Fresh Claude instance (Sonnet 4.5) with zero prior knowledge of either tool. Five difficulty levels covering console errors, network analysis, form validation, memory profiling, and batch operations. No human guidance.

**Full methodology**: [BENCHMARK_PROMPT.md](https://github.com/szymdzum/browser-debugger-cli/blob/main/docs/benchmarks/BENCHMARK_PROMPT.md)

## Results

### Overall Scores

| Tool | Score | Token Efficiency |
|------|-------|------------------|
| **bdg (CLI)** | 77/100 | 202.1 |
| **Chrome MCP** | 60/100 | 152.3 |
| **Difference** | +17 points | **33% better** |

Total token consumption was similar (~38-39K), but CLI achieved better outcomes per token spent.

### Where the Gap Shows

**Error collection**: bdg captured 18 errors with complete stack traces. MCP managed 3 errors across 11 individual click operations.

**Form validation**: A form with 195 dropdown options consumed 15,200 tokens via MCP (full accessibility dump). bdg completed the same task in 3,500 tokens using selective queries.

**Memory profiling**: bdg provided heap snapshots and allocation tracking. MCP has no access to these CDP methods. For memory debugging, that's a dealbreaker.

## Why CLI Performed Better

**Selective queries**: CLI enables targeted data retrieval rather than full-page dumps. That 195-option dropdown? 5,000 tokens via MCP snapshot, 50 tokens with a selective CLI query.

**Capability access**: CLI provided direct access to 300+ CDP methods: memory profiling, network HAR export, batch JavaScript execution. MCP exposes a curated subset.

**Predictable output**: CLI commands produce bounded, estimable token costs. MCP snapshots vary unpredictably based on page complexity.

**Unix composability**: CLI outputs pipe naturally to `jq`, `grep`, `awk`. MCP responses require agent-side parsing.

## When MCP Might Excel

MCP has advantages in specific scenarios:

- **Cross-platform integration** where protocol standardization matters
- **Sandboxed environments** requiring safety constraints
- **Accessibility testing** where comprehensive tree dumps are genuinely useful

The accessibility tree approach isn't wrong. It optimizes for different constraints than developer debugging workflows.

## Limitations

- Single model: Claude Sonnet 4.5 only
- Specific scenarios: Developer debugging workflows
- Both tools faced bot detection on some sites

## Takeaway

For developer debugging workflows, CLI provides more capability with better efficiency. MCP optimizes for protocol standardization and ecosystem integration.

Tool designers targeting AI agents should prioritize selective queries over bulk dumps. The accessibility tree approach creates inefficient token consumption without improving utility for most debugging tasks.

This isn't definitive. It's one data point. Your needs may differ.

**Full results**: [BENCHMARK_RESULTS.md](https://github.com/szymdzum/browser-debugger-cli/blob/main/docs/benchmarks/BENCHMARK_RESULTS.md)
